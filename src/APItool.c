#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdlib.h>

// This header is generated by APItool :)
#include "APItool.h"

// All public stuff is prefixed with APItool. Everything else is prefixed with S (static).

char line[1000];

int lnum;

FILE* fr;

static void _asrt(bool cnd, char* msg) {
  if(!cnd) {
   printf("Error: %s on line %d. See the docs for help.\n", msg, lnum);
   rewind(fr);
   int i;
   for(i = 0; i < lnum; i++) {
     fgets(line, sizeof(line), fr);
   }
   line[strlen(line)-1] = 0;
   printf("\n\"%s\"\n", line);
   exit(-1);
  }
}

// stolen from stackoverflow.com/questions/7623323/how-to-take-a-look-at-the-next-character-in-a-stream-in-c

static int fpeek(FILE * const fp)
{
  const int c = getc(fp);
  return c == EOF ? EOF : ungetc(c, fp);
}

// this will eat a string
static void S_nom_nom_nom(char* strtonom, char* error) {
 for(int i = 0; i < (int)strlen(strtonom); i++) {
  _asrt(getc(fr) == strtonom[i], error);
 }
}

static int S_search_argsarray(APItool_Function* f, char* key, char* errmsg) {
  for(int i = 0; i < (f->argsarray_len); i++) {
    if(strcmp(f->argsarray_names[i], key) == 0) {
      return i;
    }
  }
  _asrt(false, errmsg);
  return 0; // silence the warning about no return
}

static int S_search_typesarray(APItool_Struct_Union* f, char* key, char* errmsg) {
  for(int i = 0; i < (f->typesarray_len); i++) {
    if(strcmp(f->typesarray_names[i], key) == 0) {
      return i;
    }
  }
  _asrt(false, errmsg);
  return 0;
}

static int S_search_array(APItool_Enum* f, char* key, char* errmsg) {
  for(int i = 0; i < (f->array_len); i++) {
    if(strcmp(f->array_names[i], key) == 0) {
      return i;
    }
  }
  _asrt(false, errmsg);
  return 0;
}

static char* S_read_till_nl(char* buffer) {
  char cur;
  int i;
  for(i = 0; (cur = getc(fr)) != '\n'; i++) {
   buffer[i] = cur;
  }
  buffer[i] = 0;
  return buffer;
}

static char* S_parse_type(void) {
  _asrt(fpeek(fr) == '"', "type is missing quotes");
  char* returnv = malloc(500);
  char cur = getc(fr);
  int i;
  for(i = 0; (cur = getc(fr)) != '"'; i++) {
    returnv[i] = cur;
  }
  returnv[i] = 0;
  return returnv;
}

static char* S_parse_symbol(void) {
  char* returnv = malloc(500);
  char cur = getc(fr);
  int i;
  for(i = 0; ((cur >= 'A' && cur <= 'Z') || (cur >= 'a' && cur <= 'z') || (cur >= '0' && cur <= '9') || cur == '_' || cur == '-'); i++) {
    returnv[i] = cur;
    cur = getc(fr);
  }
  ungetc(cur, fr);
  returnv[i] = 0;
  return returnv;
}

#include "parse_specific.c"
#include "parse_token.c"

APItool_AST* APItool_parse_file(char* fname) {
 fr = fopen(fname, "r");
 lnum = 1;
 APItool_token** returnv = malloc(sizeof(APItool_token*) * 20);
 int siz = 20;
 int i;
 for(i = 0; fpeek(fr) != EOF; i++) {
  if(i >= siz) {
   siz += 20;
   returnv = realloc(returnv, sizeof(APItool_token*) * siz);
  }
  APItool_token* cr;
  switch(fpeek(fr)) {
   case '?':
    cr = S_parse_token();
    break;
   case '!':
    getc(fr);
    _asrt(getc(fr) == ' ', "space after ! required");
    cr = malloc(sizeof(APItool_token));
    cr->tt = APItool_VERBATIM;
    char* buf = malloc(1000);
    S_read_till_nl(buf);
    cr->token.verbatim = buf;
    lnum++;
    break;
   default:
    _asrt(false, "no ? or ! found");
    cr = NULL; // so the compiler doesn't complain
  }

  char cur;
  while((cur = getc(fr)) == '\n') { lnum++; } // eat newlines
  if(cur) { ungetc(cur, fr); }

  returnv[i] = cr;
 }
 APItool_AST* realret = malloc(sizeof(APItool_AST));
 realret->val = returnv;
 realret->numtokens = i;
 return realret;
}

void APItool_freeAST(APItool_AST* a) {
 for(int i = 0; i < a->numtokens; i++) {
  APItool_token* at = a->val[i];
  switch(at->tt) {
   case APItool_FUNCTION:;
    APItool_Function* f = at->token.func;
    free(f->funcname);
    free(f->returntype);
    free(f->doc->description);
    free(f->doc->returns);
    for(int j = 0; j < f->argsarray_len; j++) {
     free(f->argsarray_names[j]);
     free(f->argsarray_types[j]);
     free(f->doc->argsarray_docs[j]);
    }
    free(f->argsarray_names);
    free(f->argsarray_types);
    free(f->doc->argsarray_docs);
    free(f->doc);
    free(f);
    break;
   case APItool_VERBATIM:;
    free(at->token.verbatim);
    break;
   case APItool_VARIABLE:;
    APItool_Variable* v = at->token.var;
    free(v->varname);
    free(v->type);
    free(v->doc_description);
    free(v);
    break;
   case APItool_STRUCT_UNION:;
    APItool_Struct_Union* s = at->token.sun;
    free(s->sunname);
    free(s->doc->description);
    for(int j = 0; j < s->typesarray_len; j++) {
     free(s->typesarray_names[j]);
     free(s->typesarray_types[j]);
     free(s->doc->typesarray_docs[j]);
    }
    free(s->typesarray_names);
    free(s->typesarray_types);
    free(s->doc->typesarray_docs);
    free(s->doc);
    free(s);
    break;
   case APItool_ENUM:;
    APItool_Enum* e = at->token.enm;
    free(e->enumname);
    free(e->doc->description);
    for(int j = 0; j < e->array_len; j++) {
     free(e->array_names[j]);
     free(e->doc->typesarray_docs[j]);
    }
    free(e->array_names);
    free(e->doc->typesarray_docs);
    free(e->doc);
    free(e);
    break;
   default: break;
  }
  free(at);
 }
 free(a);
}

#include "type_linker.c"
#include "gen_pair.c"
